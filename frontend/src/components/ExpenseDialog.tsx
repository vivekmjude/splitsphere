"use client";

import { useState, useEffect } from "react";
import {
  Currency,
  Expense,
  SplitType,
  User,
  Payment,
  Split,
} from "@/types/expense";
import { useGroupsStore } from "@/store/groups-store";
import { useFriendsStore } from "@/store/friends-store";
import { calculateSplits, calculateSettlements } from "@/lib/splitCalculator";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { DatePicker } from "@/components/ui/date-picker";
import SplitEditor from "./expense/SplitEditor";
import "@/styles/animations.css";

interface ExpenseDialogProps {
  open: boolean;
  onClose: () => void;
  onSubmit: (expense: Expense) => void;
  groupId?: string;
  currentUser: User;
}

let expenseCounter = 1;

export default function ExpenseDialog({
  open,
  onClose,
  onSubmit,
  groupId,
  currentUser,
}: ExpenseDialogProps) {
  const { groups } = useGroupsStore();
  const { friends } = useFriendsStore();
  const group = groupId ? groups.find((g) => g.id === groupId) : null;
  const acceptedFriends = friends.filter((f) => f.status === "ACCEPTED");

  const [expenseData, setExpenseData] = useState(() => ({
    name: "",
    amount: "",
    description: "",
    currency: currentUser.defaultCurrency as Currency,
    splitType: "EQUAL" as SplitType,
    date: new Date(),
    selectedParticipantType: groupId
      ? "group"
      : ("just-me" as "just-me" | "friends" | "group"),
    selectedFriendIds: [] as string[],
    selectedGroupId: groupId || "",
    payments: {} as Record<string, number>,
  }));

  // Current splits generated by the SplitEditor
  const [currentSplits, setCurrentSplits] = useState<Split[]>([]);

  const [participants, setParticipants] = useState<User[]>([currentUser]);

  useEffect(() => {
    if (!groupId) return;

    setExpenseData((prev) => {
      if (
        prev.selectedParticipantType === "group" &&
        prev.selectedGroupId === groupId
      ) {
        return prev;
      }
      return {
        ...prev,
        selectedParticipantType: "group",
        selectedGroupId: groupId,
      };
    });
  }, [groupId]);

  useEffect(() => {
    const getNewParticipants = () => {
      if (expenseData.selectedParticipantType === "just-me") {
        return [currentUser];
      }

      if (expenseData.selectedParticipantType === "friends") {
        const selectedFriends = acceptedFriends.filter((friend) =>
          expenseData.selectedFriendIds.includes(friend.id)
        );
        return [currentUser, ...selectedFriends];
      }

      if (expenseData.selectedParticipantType === "group") {
        const selectedGroup = groups.find(
          (g) => g.id === expenseData.selectedGroupId
        );
        if (selectedGroup) {
          return selectedGroup.members;
        }
      }

      return [currentUser];
    };

    const newParticipants = getNewParticipants();
    if (
      JSON.stringify(newParticipants.map((p) => p.id)) !==
      JSON.stringify(participants.map((p) => p.id))
    ) {
      setParticipants(newParticipants);
    }
  }, [
    currentUser,
    acceptedFriends,
    groups,
    expenseData.selectedParticipantType,
    expenseData.selectedFriendIds,
    expenseData.selectedGroupId,
    participants,
  ]);

  useEffect(() => {
    if (!open) {
      setExpenseData((prev) => ({
        ...prev,
        name: "",
        amount: "",
        description: "",
        currency: currentUser.defaultCurrency,
        splitType: "EQUAL",
        date: new Date(),
        selectedParticipantType: groupId ? "group" : "just-me",
        selectedFriendIds: [],
        selectedGroupId: groupId || "",
        payments: {},
      }));
      setParticipants([currentUser]);
      setCurrentSplits([]);
    }
  }, [open, currentUser.defaultCurrency, groupId]);

  // Handle splits change from SplitEditor
  const handleSplitsChange = (splits: Split[]) => {
    setCurrentSplits(splits);
  };

  const handleParticipantTypeChange = (
    type: "just-me" | "friends" | "group"
  ) => {
    setExpenseData((prev) => ({
      ...prev,
      selectedParticipantType: type,
      selectedFriendIds: [],
      selectedGroupId: type === "group" ? groupId || "" : "",
    }));
  };

  const handleFriendSelection = (friendId: string, isSelected: boolean) => {
    setExpenseData((prev) => {
      const updatedFriendIds = isSelected
        ? [...prev.selectedFriendIds, friendId]
        : prev.selectedFriendIds.filter((id) => id !== friendId);

      return {
        ...prev,
        selectedFriendIds: updatedFriendIds,
      };
    });
  };

  const handleGroupSelection = (groupId: string) => {
    setExpenseData((prev) => ({ ...prev, selectedGroupId: groupId }));
  };

  const handlePaymentChange = (participantId: string, value: string) => {
    const numValue = parseFloat(value) || 0;
    setExpenseData((prev) => ({
      ...prev,
      payments: { ...prev.payments, [participantId]: numValue },
    }));
  };

  const validatePayments = (): boolean => {
    if (Object.keys(expenseData.payments).length === 0) {
      return true; // If no payments specified, it's valid (we'll default to current user)
    }

    const totalPayments = Object.values(expenseData.payments).reduce(
      (sum, val) => sum + val,
      0
    );

    return Math.abs(totalPayments - parseFloat(expenseData.amount)) < 0.01;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // Validate amount is provided
    const amount = parseFloat(expenseData.amount);
    if (isNaN(amount) || amount <= 0) {
      alert("Please enter a valid amount");
      return;
    }

    // Validate splits if needed
    if (expenseData.splitType === "UNEQUAL") {
      const totalSplitAmount = currentSplits.reduce(
        (sum, split) => sum + split.amount,
        0
      );

      if (Math.abs(totalSplitAmount - amount) > 0.01) {
        alert("Split amounts must total the expense amount");
        return;
      }
    }

    if (!validatePayments()) {
      alert("Total payments must equal expense amount");
      return;
    }

    let finalGroupId = undefined;
    if (expenseData.selectedParticipantType === "group") {
      finalGroupId = expenseData.selectedGroupId;
    }

    // Create payments array
    const payments: Payment[] = [];
    if (Object.keys(expenseData.payments).length > 0) {
      Object.entries(expenseData.payments).forEach(([userId, amount]) => {
        if (amount > 0) {
          payments.push({ userId, amount });
        }
      });
    } else {
      payments.push({ userId: currentUser.id, amount });
    }

    // Use splits from SplitEditor if available, otherwise calculate them
    let splits = currentSplits;
    if (!splits.length) {
      splits = calculateSplits({
        amount,
        splitType: expenseData.splitType,
        participants,
      });
    }

    const settlements = calculateSettlements({
      payments,
      splits,
    });

    const newExpense: Expense = {
      id: `expense-${expenseCounter++}`,
      name: expenseData.name,
      description: expenseData.description,
      amount,
      currency: expenseData.currency,
      paidBy: currentUser.id, // For backward compatibility
      payments,
      splits,
      settlements,
      date: expenseData.date.toISOString().split("T")[0],
      splitType: expenseData.splitType,
      groupId: finalGroupId,
    };

    onSubmit(newExpense);
    onClose();
  };

  const renderPaymentSection = () => {
    if (participants.length <= 1) return null;

    return (
      <div className="mt-4">
        <label className="mb-2 block text-sm font-medium">Who paid?</label>
        <div className="space-y-2">
          {participants.map((participant) => (
            <div key={participant.id} className="flex items-center gap-2">
              <span className="flex-1 text-sm">
                {participant.id === currentUser.id ? "You" : participant.name}
              </span>
              <div className="flex items-center gap-1">
                <input
                  type="number"
                  min="0"
                  step="0.01"
                  inputMode="decimal"
                  value={expenseData.payments[participant.id] || ""}
                  onChange={(e) => {
                    handlePaymentChange(participant.id, e.target.value);
                  }}
                  className="border-input w-24 rounded-md border p-2 text-right"
                  placeholder="0.00"
                />
                <span className="text-sm">{expenseData.currency}</span>
              </div>
            </div>
          ))}

          {/* Validate payments total */}
          <div
            className={`mt-1 text-sm ${
              validatePayments() ? "text-muted-foreground" : "text-red-500"
            }`}
          >
            Total:{" "}
            {Object.values(expenseData.payments).reduce(
              (sum, val) => sum + val,
              0
            )}{" "}
            {!validatePayments() && "(should equal expense amount)"}
          </div>
        </div>
      </div>
    );
  };

  if (!open) return null;

  return (
    <Dialog open={open} onOpenChange={(isOpen) => !isOpen && onClose()}>
      <DialogContent className="expense-popup-enter data-[state=closed]:expense-popup-exit max-w-xl">
        <DialogHeader>
          <DialogTitle>
            {group ? `Add Expense to ${group.name}` : "Add New Expense"}
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4 py-4">
          <div>
            <label
              htmlFor="expense-name"
              className="mb-1 block text-sm font-medium"
            >
              Expense Name
            </label>
            <input
              id="expense-name"
              type="text"
              value={expenseData.name}
              onChange={(e) =>
                setExpenseData({ ...expenseData, name: e.target.value })
              }
              className="border-input w-full rounded-md border p-2"
              placeholder="Enter expense name"
              required
            />
          </div>

          <div>
            <label
              htmlFor="expense-description"
              className="mb-1 block text-sm font-medium"
            >
              Description
            </label>
            <input
              id="expense-description"
              type="text"
              value={expenseData.description}
              onChange={(e) =>
                setExpenseData({ ...expenseData, description: e.target.value })
              }
              className="border-input w-full rounded-md border p-2"
              placeholder="Enter description (optional)"
            />
          </div>

          <div>
            <label
              htmlFor="expense-amount"
              className="mb-1 block text-sm font-medium"
            >
              Amount
            </label>
            <div className="flex gap-2">
              <input
                id="expense-amount"
                type="text"
                inputMode="decimal"
                value={expenseData.amount}
                onChange={(e) => {
                  // Only allow numbers and decimal point
                  const value = e.target.value;
                  if (value === "" || /^(\d*\.?\d{0,2})$/.test(value)) {
                    setExpenseData({ ...expenseData, amount: value });
                  }
                }}
                className="border-input flex-1 rounded-md border p-2"
                placeholder="Enter amount"
                required
              />
              <select
                id="expense-currency"
                aria-label="Currency"
                value={expenseData.currency}
                onChange={(e) =>
                  setExpenseData({
                    ...expenseData,
                    currency: e.target.value as Currency,
                  })
                }
                className="border-input rounded-md border p-2"
              >
                <option value="USD">USD</option>
                <option value="EUR">EUR</option>
                <option value="GBP">GBP</option>
                <option value="INR">INR</option>
              </select>
            </div>
          </div>

          <div>
            <label
              htmlFor="expense-date"
              className="mb-1 block text-sm font-medium"
            >
              Date
            </label>
            <DatePicker
              date={expenseData.date}
              setDate={(date) =>
                date && setExpenseData({ ...expenseData, date })
              }
            />
          </div>

          <div>
            <label className="mb-1 block text-sm font-medium">Split With</label>
            <div className="space-y-2">
              <label className="flex items-center gap-2">
                <input
                  type="radio"
                  checked={expenseData.selectedParticipantType === "just-me"}
                  onChange={() => handleParticipantTypeChange("just-me")}
                  className="border-input rounded"
                />
                <span>Just me</span>
              </label>

              <label className="flex items-center gap-2">
                <input
                  type="radio"
                  checked={expenseData.selectedParticipantType === "friends"}
                  onChange={() => handleParticipantTypeChange("friends")}
                  className="border-input rounded"
                />
                <span>Select friends</span>
              </label>

              {expenseData.selectedParticipantType === "friends" && (
                <div className="mt-2 space-y-2 pl-6">
                  {acceptedFriends.map((friend) => (
                    <label key={friend.id} className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={expenseData.selectedFriendIds.includes(
                          friend.id
                        )}
                        onChange={(e) =>
                          handleFriendSelection(friend.id, e.target.checked)
                        }
                        className="border-input rounded"
                      />
                      <span>{friend.name}</span>
                    </label>
                  ))}
                </div>
              )}

              {!groupId && (
                <label className="flex items-center gap-2">
                  <input
                    type="radio"
                    checked={expenseData.selectedParticipantType === "group"}
                    onChange={() => handleParticipantTypeChange("group")}
                    className="border-input rounded"
                  />
                  <span>Select group</span>
                </label>
              )}

              {expenseData.selectedParticipantType === "group" && !groupId && (
                <div className="mt-2 pl-6">
                  <select
                    value={expenseData.selectedGroupId}
                    onChange={(e) => handleGroupSelection(e.target.value)}
                    className="border-input w-full rounded-md border p-2"
                    aria-label="Select a group"
                  >
                    <option value="">Select a group</option>
                    {groups.map((group) => (
                      <option key={group.id} value={group.id}>
                        {group.name}
                      </option>
                    ))}
                  </select>
                </div>
              )}
            </div>
          </div>

          {participants.length > 1 && (
            <div>
              <label
                htmlFor="split-type"
                className="mb-1 block text-sm font-medium"
              >
                Split Type
              </label>
              <select
                id="split-type"
                value={expenseData.splitType}
                onChange={(e) => {
                  setExpenseData({
                    ...expenseData,
                    splitType: e.target.value as SplitType,
                  });
                }}
                className="border-input w-full rounded-md border p-2"
              >
                <option value="EQUAL">Equal Split</option>
                <option value="UNEQUAL">Unequal Split</option>
                <option value="PERCENTAGE">Percentage Split</option>
              </select>
            </div>
          )}

          {/* Use the centralized SplitEditor component */}
          {participants.length > 0 && expenseData.amount && (
            <SplitEditor
              participants={participants}
              splitType={expenseData.splitType}
              totalAmount={parseFloat(expenseData.amount) || 0}
              currency={expenseData.currency}
              onSplitsChange={handleSplitsChange}
              currentUserId={currentUser.id}
            />
          )}

          {renderPaymentSection()}

          <div className="mt-6 flex justify-end gap-2">
            <Button type="button" onClick={onClose} variant="outline">
              Cancel
            </Button>
            <Button type="submit" variant="default">
              Add Expense
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
